#lang sicp

;; Упражнение 1.7.
;; Проверка good-enough?, которую мы использовали для вычисления
;; квадратных корней, будет довольно неэффективна для поиска квадратных
;; корней от очень маленьких чисел. Кроме того, в настоящих компьютерах
;; арифметические операции почти всегда вычисляются с ограниченной
;; точностью. Поэтому наш тест оказывается неадекватным и для очень
;; больших чисел. Альтернативный подход к реализации good-enough? состоит
;; в том, чтобы следить, как от одной итерации к другой изменяется guess,
;; и остановиться, когда изменение оказывается небольшой долей значения
;; приближения.  Разработайте процедуру вычисления квадратного корня,
;; которая использует такой вариант проверки на завершение. Верно ли, что
;; на больших и маленьких числах она работает лучше?

;; Решение:
;; Возьмём за основу алгоритм поиска квадратного корня прошлой версии

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x)
  (* x x))

;; Приближение guess достаточно хорошее если разность квадрата guess и x меньше
;; чем 0.001
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt x)
  (sqrt-iter 1.0 x))

;; Проверим вычисление квадратного корня маленького числа этой функцией:

(sqrt 4)
;; Output: 2.0000000929222947

;; Попробуем переписать функцию проверки приближения. Из возможных вариантов
;; этот считает с максимальной возможной точностью, так как приближение
;; считается хорошим только когда оно уже не изменяется.
(define (new-good-enough? guess x)
  (= guess (improve guess x)))

;; Перепишем другие функции для использования новой функции приближения:
(define (new-sqrt-iter guess x)
  (if (new-good-enough? guess x)
      guess
      (new-sqrt-iter (improve guess x) x)))

(define (new-sqrt x)
  (new-sqrt-iter 1.0 x))

;; Проверяем на том же числе 4
(new-sqrt 4)
;; Output: 2.0
