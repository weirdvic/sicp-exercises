#lang sicp

;; Упражнение 1.11.

;; Функция f определяется правилом: f(n) == n, если n < 3, и f(n) ==
;; f(n-1) + 2 * f(n-2) + 3 * f(n-3), если n >= 3. Напишите процедуру, вычисляющую
;; f с помощью рекурсивного процесса. Напишите процедуру, вычисляющую f с
;; помощью итеративного процесса.

;; Решение:

;; Вариант с рекурсивным процессом:

(define (f-recursive n)
  (if (< n 3)
      n
      (+ (f-recursive (- n 1))
         (* 2 (f-recursive (- n 2)))
         (* 3 (f-recursive (- n 3))))))

;; Здесь всё относительно просто: если n больше трёх, для вычисления
;; возвращаемого значения функция вызывается рекурсивно с изменёнными
;; аргументами.

;; Вариант с итеративным процессом:

;; Написание итеративной версии далось мне сложнее чем написание
;; рекурсивного алгоритма. Чтобы понять как работает этот код, нужно
;; разобрать итеративный вычислительный процесс. Сначала попробую
;; продемонстрировать его через аналогичный код на Python:

;; def f(n):
;;     def iter(a, b, c, counter):
;;         if counter == 0:
;;             return a
;;         else:
;;             return iter((a + 2*b + 3*c), a, b, counter-1)
;;     return iter(2, 1, 0, (n-2))

;; Приглядимся получше к функции вычисления f(n) для n >= 3:
;; f(n) == f(n-1) + 2 * f(n-2) + 3 * f(n-3)

;; Для вычисления f(n) итеративным методом нам нужно хранить три значения:
;; f(n-1), f(n-2) и f(n-3). Для хранения этих значений между итерациями
;; и нужны переменные a, b и с в коде.
;; Внутри внешней функции f мы определяем функцию iter. Эта функция возвращает
;; значение a когда значение переменной counter равняется 0.

;; a <- a + 2*b + 3*c
;; b <- a
;; c <- b

;; В результате возвращаем значение переменной a как результат f(n).

;; Теперь попробуем переписать тот же алгоритм на Scheme:

(define (f-iterative n)
  (define (iter a b c counter)
    (if (= counter 0)
        a
        (iter (+ a (* 2 b) (* 3 c)) a b (- counter 1))))
  (iter 2 1 0 (- n 2)))

;; Попробуем развернуть выполнение этой функции для n == 5:
;; (f-iterative 5)
;; (iter 2 1 0 (- 5 2))
;; (iter 2 1 0 3)
;; 3 != 0
;; (iter (+ 2 (* 2 1) (* 3 0)) 2 1 (- 3 1))
;; (iter 4 2 1 2)
;; 2 != 0
;; (iter (+ 4 (* 2 2) (* 3 1)) 4 2 (- 2 1))
;; (iter 11 4 2 1)
;; 1 != 0
;; (iter (+ 11 (* 2 4) (* 3 2)) 11 4 (- 1 1))
;; (iter 25 11 4 0)
;; 0 == 0
;; 25
