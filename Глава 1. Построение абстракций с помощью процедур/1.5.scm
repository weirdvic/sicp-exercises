#lang sicp

;; Упражнение 1.5
;; Бен Битобор придумал тест для проверки интерпретатора но то, с каким порядком
;; вычислений он работает, аппликативным или нормальным.
;; Бен определяет такие две процедуры
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

;; Затем он вычисляет выражение:
(test 0 (p))

;; Какое поведение увидит Бен, если интерпретатор использует аппликативный
;; порядок вычислений? Какое поведение он увидит, если интерпретатор
;; использует нормальный порядок? Объясните ваш ответ.
;; Предполагается, что правило вычисления особой формы if одинаково
;; независимо от того, какой порядок вычислений используется.
;; Сначала вычисляется выражение-предикат, и резуальтат определяет, нужно ли
;; вычислять выражение-следствие или альтернативу.

;; Решение:

;; Если интерпретатор использует аппликативный порядок вычислений, сначала
;; полностью вычисляются операнды, а затем происходит их подстановка в
;; вычисляемое выражение. Таким образом, попытка вычислить
;; (test 0 (p))
;; потребует вычислить (p) чтобы подставить значение в функцию test.
;; Но так как (p) определена через саму себя, для вычисления (p) нужно
;; вычислить (p) и так до бесконечности, интерпретатор зацикливается.
;; При нормальном порядке вычислений, операнды вычисляются не заранее, а по
;; мере их использования в функциях, поэтому сначала будет вычислен предикат
;; блока if, который в нашем случае окажется истиным и функция вернёт 0, ещё
;; до вычисления (p)